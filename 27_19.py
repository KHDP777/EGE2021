# Набор данных состоит из троек натуральных чисел. Необходимо распределить все числа на три группы,
# при этом в каждую группу должно попасть ровно одно число из каждой исходной тройки.
# Сумма всех чисел в первой группе должна быть чётной, во второй — нечётной.
# Определите минимально возможную сумму всех чисел в третьей группе.
f = open("27_19.txt")
N = int(f.readline())
minim = 10000000
sumFin = 0
sumS = 0
sumT = 0
buffer = []
for i in range(N):
    first, second, third = f.readline().split()
    first = int(first)
    second = int(second)
    third = int(third)
    buffer.append(first)
    buffer.append(second)
    buffer.append(third)
# Для удобства добавляем три числа в массив и сортируем его
    buffer.sort()
# В третью всегда кидаем самое мелкое число
    sumFin += buffer[0]
# Во второе всегда кидаем среднее число
    sumS += buffer[1]
# В третью всегда кидаем большое число
    sumT += buffer[2]
# Так как нам нужно чтобы в двух масисвах была разная четность, то мы предварително ищем минимальный разрыв между
# минимальным числом и ыторым или третьим(на случай замены)
# Проверяем минимальный разрыв между минимальным и пред минимальным и оно должно быть нечетное
    if (buffer[1]-buffer[0]) <= minim and (buffer[1]-buffer[0]) % 2 == 1:
        minim = buffer[1]-buffer[0]
# Проверяем минимальный разрыв между минимальным и предпред минимальным и оно должно быть нечетное
    elif (buffer[2]-buffer[0]) <= minim and (buffer[2]-buffer[0]) % 2 == 1:
        minim = buffer[2]-buffer[0]
# очищаем временный массив
    buffer.clear()
print(minim)
# И преряем четность суммы двух оставшихся массивов. если их сумма четна, то это значит что они оба или четные
# или нечетные и тогда нужно изменить их четность доабвив в исходную сумму минимальный разрыв
if (sumS + sumT) % 2 != 0:
    print(sumFin)
else:
    print(sumFin + minim)
